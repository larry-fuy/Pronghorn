package com.ociweb.pronghorn.stage.network;

import static org.junit.Assert.*;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

import org.junit.Assert;
import org.junit.Ignore;
import org.junit.Test;

import com.ociweb.pronghorn.network.HTTPModuleFileReadStage;
import com.ociweb.pronghorn.network.config.HTTPContentTypeDefaults;
import com.ociweb.pronghorn.network.config.HTTPSpecification;
import com.ociweb.pronghorn.network.config.HTTPVerbDefaults;
import com.ociweb.pronghorn.network.schema.HTTPRequestSchema;
import com.ociweb.pronghorn.network.schema.ServerResponseSchema;
import com.ociweb.pronghorn.pipe.Pipe;
import com.ociweb.pronghorn.pipe.PipeConfig;
import com.ociweb.pronghorn.pipe.PipeReader;
import com.ociweb.pronghorn.pipe.util.hash.IntHashTable;
import com.ociweb.pronghorn.pipe.util.hash.IntHashTableVisitor;
import com.ociweb.pronghorn.stage.monitor.MonitorConsoleStage;
import com.ociweb.pronghorn.stage.scheduling.GraphManager;
import com.ociweb.pronghorn.stage.scheduling.ThreadPerStageScheduler;
import com.ociweb.pronghorn.stage.test.PipeCleanerStage;

public class HTTPModuleFileReadStageTest {

    
    @Test
    public void rapidValidReadTest() {
        
        GraphManager gm = new GraphManager();

        //1 -20 gb is not hard to saturate, above this is scales more slowly and it never reaches 40 gb (may work on new PCIe hardware...)
        int fileCount = 20;
        int fileSize = 3000;//selected to make the output 20gbs
        int iterations = 10_000;//500_000;
        HTTPVerbDefaults verb = HTTPVerbDefaults.GET;//HTTPVerbDefaults.HEAD; //HTTPVerbDefaults.GET;
        
        //logger.info("fileSize is "+fileSize);//plus the header
                
        long totalRequests = iterations*(long)fileCount;
        long expectedBytes = totalRequests*fileSize;

        PipeConfig<HTTPRequestSchema> requestConfig = new PipeConfig<HTTPRequestSchema>(HTTPRequestSchema.instance, 100, 80);
        PipeConfig<ServerResponseSchema> responseConfig = new PipeConfig<ServerResponseSchema>(ServerResponseSchema.instance, 10, 4000);
                
        Pipe<HTTPRequestSchema> requestPipe =  new Pipe<HTTPRequestSchema>(requestConfig);
        Pipe<ServerResponseSchema> responsePipe = new Pipe<ServerResponseSchema>(responseConfig);
               
        StaticFileRequestGeneratorStage gs = StaticFileRequestGeneratorStage.newInstance(gm, requestPipe, iterations, fileCount, fileSize, verb);  
        //PipeCleanerStage.newInstance(gm, requestPipe);//generates about 15m req/sec
                
        //can not be watched, does not shutdown.
        HTTPModuleFileReadStage<?, ?, ?, ?> watch = HTTPModuleFileReadStage.newInstance(gm, requestPipe, responsePipe, HTTPSpecification.defaultSpec(), gs.tempFolder());

        responsePipe.initBuffers();        
        
        
//        MonitorConsoleStage.attach(gm);        
        GraphManager.enableBatching(gm);
        
        
        ThreadPerStageScheduler scheduler = new ThreadPerStageScheduler(gm);
        
        
        long start = System.currentTimeMillis();       
        scheduler.startup();  
        
        long runningLen = 0;
        int expectedSequenceNumber = 0;
		while (Pipe.contentRemaining(responsePipe)>0 || (!  (GraphManager.isStageShuttingDown(gm, gs.stageId)||GraphManager.isStageTerminated(gm, gs.stageId))) ) { 
        	while (PipeReader.tryReadFragment(responsePipe)) {
    		
        		assertEquals(ServerResponseSchema.MSG_TOCHANNEL_100, PipeReader.getMsgIdx(responsePipe));
        		//Must confirm the data matches
        		
        		long channelId = PipeReader.readLong(responsePipe, ServerResponseSchema.MSG_TOCHANNEL_100_FIELD_CHANNELID_21);
        		assertEquals("This test only uses the single chamnel ",0,channelId);
        		
        		
        		//sequence number is generated by the orginal request. The response for the file may be delieverd in parts which each will have the same number
        		int seqNo = PipeReader.readInt(responsePipe, ServerResponseSchema.MSG_TOCHANNEL_100_FIELD_SEQUENCENO_23);
        		assertTrue(seqNo==expectedSequenceNumber || (seqNo==(expectedSequenceNumber+1)));
        		
        		if (expectedSequenceNumber!=seqNo) {        	
        			assertTrue("sent data with header must be larger than the file size alone",runningLen>fileSize);
        		
        			//start new running len;
        			runningLen = 0;
        			expectedSequenceNumber=seqNo;        			
        		}        		      	       		
        		
        		long length = PipeReader.readBytesLength(responsePipe, ServerResponseSchema.MSG_TOCHANNEL_100_FIELD_PAYLOAD_25);
        		runningLen += length;
        		
        		
	    		PipeReader.releaseReadLock(responsePipe);
	    	}

		}
        
               
        scheduler.awaitTermination(60, TimeUnit.MINUTES);      
                
        
        long duration = System.currentTimeMillis()-start;
        float requestPerMsSecond = totalRequests/(float)duration;
        System.out.println("totalFileRequests: "+totalRequests+" perMs:"+requestPerMsSecond+" duration:"+duration);
        System.out.println("data bytes:"+expectedBytes+" plus headers");
        
        
    }
    
    //TODO: add generator for fuzz test of invalid file name.
    
    @Test
    public void testFileExtCollide() {
        IntHashTable table = HTTPModuleFileReadStage.buildFileExtHashTable(HTTPContentTypeDefaults.class);
       
        final AtomicInteger count = new AtomicInteger();
        
        IntHashTableVisitor visitor = new IntHashTableVisitor(){

          @Override
          public void visit(int key, int value) {
             //System.out.println("key "+key+" value "+value);
             
             HTTPContentTypeDefaults type = HTTPContentTypeDefaults.values()[value];
             
             Assert.assertEquals( HTTPModuleFileReadStage.extHash(type.fileExtension()), key);

             count.incrementAndGet();             
              
          }
          
       };
      IntHashTable.visit(table, visitor );
      
      int c = HTTPContentTypeDefaults.values().length;
      int total = 0;
      while (--c>=0) {
          if (!HTTPContentTypeDefaults.values()[c].isAlias()) {
              total++;
          }
      }      
      Assert.assertEquals(count.get(),total);
      
    }
    
    
    
}
